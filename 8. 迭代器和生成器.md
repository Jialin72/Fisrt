# 学习材料：[解释yield和生成器](https://www.oschina.net/translate/improve-your-python-yield-and-generators-explained)
# 生成器（generator）
## [生成器函数](https://zhuanlan.zhihu.com/p/33820948)
生成器是一种可以简单有效的创建迭代器的工具。它们像常规函数一样撰写，但是在需要返回数据时使用yield语句。每当对它调用next()函数(有关next函数下面会提及)，生成器从它上次停止的地方重新开始（它会记住所有的数据值和上次执行的语句）。
`def部分定义了一个生成器函数，print_letter("hello")这行代码将返回一个生成器。为了理解生成器(即def定义的部分)，我们可以从函数的角度理解，当调用函数时，代码是按顺序结构执行的，生成器与函数的区别在于，函数遇到return返回，而生成器执行到yield时返回yield之后的语句；另外，函数返回时会释放内部定义的变量，而生成器则会保持退出时的状态。以上面代码为例，如果print_letter是函数，那么只返回一次数据(将yield改成return，也就是返回data[0])；但对于生成器，它将在一次调用后接着进入之前的状态，执行代码，每次都返回yield后的语句，直到不再满足条件时停止(对于这里的例子，yield第一次返回data[0]，第二次返回data[1]，以此类推，当不再满足for遍历条件时就不再返回yield后的语句了)。除了使用for遍历以外，生成器可以不断调用next()函数来实现“遍历”，另外需要指出的是，如果你用next函数遍历完生成器后，程序将会抛出一个StopIteration的异常。
def print_letter(data):
    for index in range(len(data)):
        yield data[index]

g=print_letter('Hello')
for i in g: print(i)
H
e
l
l
o`
`type(g)
Out: generator`
## 生成器表达式
*除了像函数那样定义一个生成器之外，还有一种定义生成器的简单方法。即生成器表达式。
**介绍生成器表达式之前我们先介绍一下和它长的很像的列表生成式（List Comprehension），看下面实例：
` 两种方式产生列表[1,4,9,16]
ls = []
for i in range(1,5):
    ls.append(i*i)

等价于

ls = [i**i for i in range(1,5)]   # 列表解析式`
> 列表生成式是一种定义列表的简洁方法，实际中也推荐大家使用，这种写法更加pythonic。知道了列表生成式，就很容易得到生成器表达式了。
> `以上面的代码为例，要把列表生成式修改成生成器表达式，只需要把[]改为()，即:
>g = (i**i for i in range(1,5))  # 生成器表达式
>type(g)
>Out[28]: generator
`
**构建一个生成器有两种方式，1.生成器函数 2.生成器表达式 。按照实际情况选择。**
***
# [迭代器和生成器](https://zhuanlan.zhihu.com/p/26123333)和[资料](https://nvie.com/posts/iterators-vs-generators/)

## 首先是一个概念的区分<img width="497" alt="捕获-迭代器和生成器" src="https://user-images.githubusercontent.com/86276719/123934991-67040200-d9c6-11eb-94ba-bdcb7fa728b6.PNG">

1 containers
> containers is data structure holding elements and support membership tests. like, list,set, dict, tuple,str ...
**container is not a type of object.**
2 iterables
> mostcontainers are also iterable. but many more things are iterable  as well. Examples are open files, open sockets etc.
> AN iterable is any object, not necessarily a data structure, that can return an iterator.
> **so. iterable is a kind of quality that can produce iterator**
3. iterator
> iterator is a kind of object.
> `x = [1, 2, 3]
>>> y = iter(x)
>>> z = iter(x)
>>> next(y)
1
>>> next(y)
2
>>> next(z)
1
>>> type(x)
<class 'list'>
>>> type(y)
<class 'list_iterator'>`

> **Often, for pragmatic reasons, iterable classes will implement both __iter__() and __next__() in the same class, and have __iter__() return self, which makes the class both an iterable and its own iterator. It is perfectly fine to return a different object as the iterator, though.**
> so any classes (and so is any kind of object) can be an iterator. an iterator is necesarily related to data struture (such as container). the only reqiurement of being 
> an iterator is the (iterable) **classess will implement both __iter__() method and __next__()method in the same class. the former magic method makes the class iterable
> and make its instances an iterator. the __next__()method is like next() function, returning next value if asked.

<img width="538" alt="捕获-迭代器和生成器1" src="https://user-images.githubusercontent.com/86276719/123937514-d5e25a80-d9c8-11eb-8aee-3105d04f047b.PNG">

>Any object that has a __next__() method is therefore an iterator
>So an iterator is a value factory.
>**example: a function as iterator**
>` >>> class fib:
...     def __init__(self):
...         self.prev = 0
...         self.curr = 1
... 
...     def __iter__(self):
...         return self
... 
...     def __next__(self):
...         value = self.curr
...         self.curr += self.prev
...         self.prev = value
...         return value
...
>>> f = fib()
>>> list(islice(f, 0, 10))
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55] `

**Note that this class is both an iterable (because it sports an __iter__() method), and its own iterator (because it has a __next__() method).**
**Central idea: a lazy factory   
From the outside, the iterator is like a lazy factory that is idle until you ask it for a value, which is when it starts to buzz and produce a single value, after which it turns idle again. **

## generator 
generator is a function with "yield statement" instead of "return"
gengerator can also be a simplified expression: so called generator expression.
**There are two types of generators in Python: generator functions and generator expressions. A generator function is any function in which the keyword yield appears in its body.The appearance of the keyword yield is enough to make the function a generator function.**
**The other type of generators are the generator equivalent of a list comprehension.**
`1.list comprehension
numbers = [1, 2, 3, 4, 5, 6]
>>> [x * x for x in numbers]
[1, 4, 9, 16, 25, 36]
2. set comprehension
 {x * x for x in numbers}
{1, 4, 36, 9, 16, 25}
3. dict comprehension
{x: x * x for x in numbers}
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
4. this is no tuple comprehension because tuple comprehension is per se generator itself
lazy_squares = (x * x for x in numbers)
>>> lazy_squares
<generator object <genexpr> at 0x10d1f5510>
>>> next(lazy_squares)
1
>>> list(lazy_squares)
[4, 9, 16, 25, 36] ` 

***
so the two generator is charactered with "yield"  and "for " respectively.
    
