# 学习材料：[解释yield和生成器](https://www.oschina.net/translate/improve-your-python-yield-and-generators-explained)
# 生成器（generator）
## [生成器函数](https://zhuanlan.zhihu.com/p/33820948)
生成器是一种可以简单有效的创建迭代器的工具。它们像常规函数一样撰写，但是在需要返回数据时使用yield语句。每当对它调用next()函数(有关next函数下面会提及)，生成器从它上次停止的地方重新开始（它会记住所有的数据值和上次执行的语句）。
`def部分定义了一个生成器函数，print_letter("hello")这行代码将返回一个生成器。为了理解生成器(即def定义的部分)，我们可以从函数的角度理解，当调用函数时，代码是按顺序结构执行的，生成器与函数的区别在于，函数遇到return返回，而生成器执行到yield时返回yield之后的语句；另外，函数返回时会释放内部定义的变量，而生成器则会保持退出时的状态。以上面代码为例，如果print_letter是函数，那么只返回一次数据(将yield改成return，也就是返回data[0])；但对于生成器，它将在一次调用后接着进入之前的状态，执行代码，每次都返回yield后的语句，直到不再满足条件时停止(对于这里的例子，yield第一次返回data[0]，第二次返回data[1]，以此类推，当不再满足for遍历条件时就不再返回yield后的语句了)。除了使用for遍历以外，生成器可以不断调用next()函数来实现“遍历”，另外需要指出的是，如果你用next函数遍历完生成器后，程序将会抛出一个StopIteration的异常。
def print_letter(data):
    for index in range(len(data)):
        yield data[index]

g=print_letter('Hello')
for i in g: print(i)
H
e
l
l
o`
`type(g)
Out: generator`
## 生成器表达式
*除了像函数那样定义一个生成器之外，还有一种定义生成器的简单方法。即生成器表达式。
**介绍生成器表达式之前我们先介绍一下和它长的很像的列表生成式（List Comprehension），看下面实例：
` 两种方式产生列表[1,4,9,16]
ls = []
for i in range(1,5):
    ls.append(i*i)

等价于

ls = [i**i for i in range(1,5)]   # 列表解析式`
> 列表生成式是一种定义列表的简洁方法，实际中也推荐大家使用，这种写法更加pythonic。知道了列表生成式，就很容易得到生成器表达式了。
> `以上面的代码为例，要把列表生成式修改成生成器表达式，只需要把[]改为()，即:
>g = (i**i for i in range(1,5))  # 生成器表达式
>type(g)
>Out[28]: generator
`
**构建一个生成器有两种方式，1.生成器函数 2.生成器表达式 。按照实际情况选择。**
***
# [迭代器和生成器](https://zhuanlan.zhihu.com/p/26123333)和[资料](https://nvie.com/posts/iterators-vs-generators/)




