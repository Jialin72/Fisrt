python作为函数式编程+面对对象的编程，它的主要特征就是依靠**定义**函数和**定义**类来进行模块化编程。这与前面提到的编程层级（hierarchy）相通：这是编程的第二层级（函数和模块）；这些函数和模块编程的基础
是前面所提到的for/if 语句，其他函数或者模块。

# 函数
> 作为函数式编程的体现，在python中可以很容易地【定义函数】（这与数学上的函数不同，数学上函数概念来自映射；而python编程中函数概念是为了完成某项目的而封装的语句statements——-它不再是简单的映射关系，
而是包含更丰富的statements,因而能完成自由度更高的目标任务）。本质上，函数是一组命令语句statements的封装，将其命名为函数名，以便重复利用。数学上函数主要目的是为了研究数量关系，而编程中函数的性质是
用来将task分解成若干【定义清晰的】子任务，每个【子任务】就是由一个函数来完成。总的来看，函数定义在数学和编程中在定义和目标同明显不同，没必要统一理解，他们是不同的事物。

在编程中函数的概念重点在**定义**（规则）,而不在函数. 但是跟数学函数有一个最相同的点： 都是必然有输入输出。

def function_name(arg1,arg2,...):
  statements
  return value
## 参数
  1.函数中`*arg`一般称为形式参数（formal argument），简记形参（形参可以有多个）。**定义**好函数f()后，输入f(2)就将2赋值给形参x，此处2称为实际参数（actual argument）,简记实参。在调用函数时候
  （call function），实际上是把实参传递给了形参；然后执行函数体（function body），并将结果作为函数值返回。（函数必然有返回值）
  2. 在微积分中对于多元函数f(x1,x2,x3)，需要区分自变量x1,x2,x3.类似地，在调用python函数f(1,2,3)的时候,其实是**通过位置来区分参数的**，称为位置参数（position parameters）,即第一个参数表示x1;
   第二个参数表示x2。如果参数过多，则通过位置类区分参数就不太可行，此时，使用的是**关键字参数**（keyword parameters）;f(x3=3;x2=1;x1=2)。
   *显然，如果使用关键词参数，则参数的位置就无所谓了。进一步，位置参数和关键字参数可以混用（要点是位置参数在前，关键字参数在后）*
   比如 
   def f(x1,x2=2,x3=3):
      print(x1,x2,x3)
  在定义函数时候，还可以设定关键字参数的默认值default。对于有默认值的关键字参数，在调用函数的时候可以省略
  f(1)
  out: 1 2 3
  用户依然可以设定关键字参数取值
  f(1,3,5)
  out: 1 3 5
  3. 有些情况下，我们不设定参数个数和形式。此时可以用“*args”来收集所有**未匹配的位置参数（unmathed positional arguments）**.（在调用该函数时候，python将所有未匹配的位置参数构成一个**元组**）
  `def f(*args): print(args)
  f(1)
  out:
  (1,)
  f(1,2,3)
  out:
  (1,2,3)`
  * 类似，用`**arg`表示未匹配关键字参数（unmatched keyword arguments）。不同的是在调用函数时候，python将未匹配的关键字参数构成一个**字典（dict）**
  `def f(**args): print(args)
f(x1=1,x2=2) 
out:
{'x1':1, 'X2':2}`

## 函数对象
def 语句定义的函数也是一个对象，称为**函数对象（function object）**，
`type(f)  ## f是函数,f(x)是函数值
out: function`
根据设定，oop编程中所有都是对象object,并且不同的对象具有相应的属性和方法。
类似地，函数作为一个object，同样具有相应地属性和方法,并且可以被其他函数调用。

1.第一个例子就是**闭包**(嵌套函数)：
`def maker(n):
  def power(x):
    return x**n
  return power  # 返回的是一个函数名
 > 在外层函数maker(n)，定义了一个n次幂函数power,并返回函数对象power.
 > suqare=maker(2) # 因为maker(n)返回的是一个函数 power,所以square也是一个函数对象
 > square(3)
 > out:9
 > cube=maker(3)
 > cube(3)
 > out: 27`
2. 第二个例子是**递归函数（recursive function）**:
def fib(n):
   if n==0 or n==1:
    return n
   else:
    return fib(n-1)+fib(n-2)
> 在用def 语句定义函数fib（）的时候，又调用了它自身fib()，故名“递归”
## 全局变量和局部变量（由函数内外环境规定）
函数可以从全局环境中读取数据，但是函数内部计算过程与结果仅存在于该函数内部的**局部环境**;不影响全局环境。
x=66
def f(y):
  z=x+y
  return z
f(10)
out:76

另一个例子：
x=66
def f(y):
  x=88
  z=x+y
  return z
f(10)
out:98
x
out:66
*在def语句内部，定义了局部变量x,但是此局部变量x(取值88)并不影响全局环境中的全局变量x(取值66)*

## lambda 表达式（lambda expression）
>在有些情况下，我们定义的函数非常简单，甚至不需要定义函数名（比如仅用一次该函数），就有匿名函数lambda 表达式
>（python中很多便于编程的表达式：比如列表解析式，字典解析式，生成器（后面详解），条件表达式）
>回到lambda 表达式
`lambda arguments: experssion`
例子：
`lambda x :x+1 # 本质上上述表达式就是一个函数，只要在lambda表达式外面加上圆括号（）,就可以当作函数应用
（lambda x :x+1）（2）
out:3
`
*lambda 表达式经常与python的map()函数一起使用，作为一个类生成器（生成可迭代对象）——-关于迭代器和生成器在另一个地方学习*
`def square(x):
    return x**2
 list1=[1,2,3]
 list(map(square,list))
 out:[1,4,9]
 
 *用lambda 表达式*
list(map(lambda x: x**2, list1))
out:[1,4,9]`
 注释：
 map()函数是将某个函数（对象）作用于第二个对象（可迭代）对象的每个元素。在原来的命令中，def 语句定义了一个平方函数square(),然后用map()函数调用该square函数，所用于list1每个元素中。其中，作为函数
 函数的square，也是一个对象（函数对象），故可以作为参数传给map()函数。在后一个例子中，lambda函数也是作为函数对象（作为map()函数参数的）。
 
 
# 类
